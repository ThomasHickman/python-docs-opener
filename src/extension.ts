import * as vscode from "vscode";
import { getWebPageFromSymbolUsingSettings, HelpFetcher } from "./internals";
import * as fsPromise from "fs/promises";
import * as fs from "fs";
import * as path from "path";
import * as child_process from "child_process"
import { getPythonWebPageFromSymbol } from "./getPythonWebPageFromSymbol";

let helpFetcherPromise: Promise<HelpFetcher>;



export function runProcess(name: string, args: string[], options: child_process.ExecFileOptions = {}): 
    Promise<{exitCode: number, error: child_process.ExecFileException | null}> {
    return new Promise((resolve, reject) => {
        let process: child_process.ChildProcess | undefined = undefined;
        process = child_process.execFile(name, args, {}, (error, stdout, stderr) => {
            if (process) {
                resolve({exitCode: process.exitCode ?? -1, error: error});
            }
            else {
                reject(Error("No process generated by execFile!"));
            }
        })
    })
}

export async function getPythonExecutableWithJedi(venvFolder: string): Promise<string> {
    let potentialPythonPath: string;
    if (process.platform == "win32") {
        potentialPythonPath = path.join(venvFolder, "Scripts", "python.exe");
    }
    else {
        potentialPythonPath = path.join(venvFolder, "bin", "python3");
    }

    if (await fsPromise.access(potentialPythonPath, fs.constants.F_OK).then(_ => true).catch(_ => false)) {
        const testCommand = await runProcess(potentialPythonPath, ["-c", "import jedi"]);
        // If the folder is in an invalid state (maybe from before where there was no internet), remove it and retry.
        if (testCommand.exitCode != 0) {
            await fsPromise.rm(venvFolder, { recursive: true, force: true });
            return await getPythonExecutableWithJedi(venvFolder);
        }


        return potentialPythonPath;
    }
    else {
        // This should error with the exit code
        let pythonCommand: string;
        if ((await runProcess("python", ["-c", "import sys; assert sys.version_info[0] == 3"])).exitCode == 0) {
            pythonCommand = "python";
        }
        else if ((await runProcess("python3", ["-c", "import sys; assert sys.version_info[0] == 3"])).exitCode == 0) {
            pythonCommand = "python3";
        }
        else {
            const errorMessage = `Cannot find a Python 3 executable. Check that you have Python 3 in your path.`;

            vscode.window.showErrorMessage(errorMessage);
            throw Error(errorMessage);
        }

        let virtualEnvProcess = await runProcess(pythonCommand, ["-m", "virtualenv", venvFolder]);
        if (virtualEnvProcess.exitCode != 0) {
            virtualEnvProcess = await runProcess("virtualenv", [venvFolder]);
        }

        if (virtualEnvProcess.exitCode != 0) {
            const errorMessage = `Creating a virtualenv failed. Make sure you have installed virtualenv. stderr: ${virtualEnvProcess.error}`;

            vscode.window.showErrorMessage(errorMessage);
            throw Error(errorMessage);
        }

        const jediInstalled = await runProcess(potentialPythonPath, ["-m", "pip", "install", "jedi~=0.18"]);
        if (jediInstalled.exitCode != 0) {
            const errorMessage = `Running "pip install jedi" failed. stderr: ${jediInstalled.error}`;

            vscode.window.showErrorMessage(errorMessage);
            throw Error(errorMessage);
        }

        return potentialPythonPath;
    }
}

async function getPythonExecutableWithJediUsingExtension(extensionContext: vscode.ExtensionContext) {
    /** Returns a path to a python executable with Jedi installed in the environment. This may be 
     * created in this function if this doesn't exist.
     *  */
    if (extensionContext.globalStorageUri.scheme != "file" && extensionContext.globalStorageUri.scheme != "vscode-userdata") {
        throw Error(`globalStorageUri doesn't return a file object, it returns a ${extensionContext.globalStorageUri.scheme} object`);
    }
    const globalStoragePath = extensionContext.globalStorageUri.fsPath;
    const potentialVenvPath = path.join(globalStoragePath, "venv");
    return await getPythonExecutableWithJedi(potentialVenvPath);
}

async function getHelpFetcher(context: vscode.ExtensionContext) {
    const pythonExecutable = await getPythonExecutableWithJediUsingExtension(context);
    return new HelpFetcher(pythonExecutable);
}


function sleepPromise(milliseconds) {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, milliseconds)
    })
}

export function activate(context: vscode.ExtensionContext) {
    helpFetcherPromise = getHelpFetcher(context);

    let disposable = vscode.commands.registerCommand('pythonDocsOpener.getDocsOfSymbol', async () => {
        const editor = vscode.window.activeTextEditor;

        if (editor) {

            let isAlreadyFulfilled = false;

            await Promise.race([helpFetcherPromise.then(_ => { isAlreadyFulfilled = true }), sleepPromise(1000)]);

            let helpFetcher: HelpFetcher;
            if (!isAlreadyFulfilled) {
                helpFetcher = await vscode.window.withProgress({
                    location: vscode.ProgressLocation.Notification, cancellable: false, title: 'Initialising python-docs-opener'
                }, async (progress, token) => {
                    return await helpFetcherPromise;
                })
            }
            else {
                helpFetcher = await helpFetcherPromise;
            }

            const document = editor.document;
            const selection = editor.selection;

            const pythonPath = vscode.extensions.getExtension("ms-python.python")?.exports.settings.getExecutionDetails()?.execCommand[0]

            const symbolAtPosition = await helpFetcher.getFunctionAtPosition(
                document.fileName,
                selection.active.line + 1,
                selection.active.character + 1,
                pythonPath,
                document.getText(),
            );
            if (!symbolAtPosition) {
                vscode.window.showWarningMessage(
                    `Unable to get the documentation at the selected position. Symbol name could not be resolved.`
                );

                return;
            }
            else {
                let webpage = getPythonWebPageFromSymbol(symbolAtPosition);

                if (!webpage) {
                    const additionalLibaries: object = vscode.workspace.getConfiguration().get("pythonDocsOpener.additionalLibraryToDocsMappings") ?? {};

                    webpage = getWebPageFromSymbolUsingSettings(symbolAtPosition, additionalLibaries);

                    if (!webpage) {
                        vscode.window.showWarningMessage(
                            `Unable to get the documentation for "${symbolAtPosition}". ` +
                            `Check whether the symbol is in a built in Python module or is in \`pythonDocsOpener.additionalLibraryToDocsMappings\`.`
                        );

                        return;
                    }
                }
                await vscode.env.openExternal(vscode.Uri.parse(webpage));
            }
        }
    });


    context.subscriptions.push(disposable);
}

export async function deactivate() {
    (await helpFetcherPromise).destroy();
}
